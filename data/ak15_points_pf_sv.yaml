selection:
   ### use `&`, `|`, `~` for logical operations on numpy arrays
   ### can use functions from `math`, `np` (numpy), and `awkward` in the expression
   ### (jet_tightId==1) & (jet_no<2) & (fj_sdmass_fromsubjets>=30) & (fj_sdmass_fromsubjets<260) & (fj_pt>170) & (fj_pt<1200) & (((sample_isQCD==0) & (fj_isQCD==0)) | ((sample_isQCD==1) & (fj_isQCD==1)))

new_variables:
   ### [format] name: formula
   ### can use functions from `math`, `np` (numpy), and `awkward` in the expression
   pfcand_mask: awkward.JaggedArray.ones_like(pfcand_etarel)
   sv_mask: awkward.JaggedArray.ones_like(sv_etarel)

preprocess:
  ### method: [manual, auto] - whether to use manually specified parameters for variable standardization
  method: manual
  ### data_fraction: fraction of events to use when calculating the mean/scale for the standardization
  data_fraction: 

inputs:
   track_features:
      length: 60
      vars: 
         - track_ptrel
         - track_erel
         - track_phirel
         - track_etarel
         - track_deltaR
         - track_drminsv
         - track_drsubjet1
         - track_drsubjet2
         - track_dz
         - track_dzsig
         - track_dxy
         - track_dxysig
         - track_normchi2
         - track_quality
         - track_dptdpt
         - track_detadeta
         - track_dphidphi
         - track_dxydxy
         - track_dzdz
         - track_dxydz
         - track_dphidxy
         - track_dlambdadz
         - trackBTag_EtaRel
         - trackBTag_PtRatio
         - trackBTag_PParRatio
         - trackBTag_Sip2dVal
         - trackBTag_Sip2dSig
         - trackBTag_Sip3dVal
         - trackBTag_Sip3dSig
         - trackBTag_JetDistVal

   sv_features:
     length: 5
     vars:
        - sv_ptrel
        - sv_erel
        - sv_phirel
        - sv_etarel
        - sv_deltaR
        - sv_pt
        - sv_mass
        - sv_ntracks
        - sv_normchi2
        - sv_costhetasvpv
        - sv_dxy
        - sv_dxysig
        - sv_d3d
        - sv_d3dsig

labels:
   ### type can be `simple`, `custom`
   ### [option 1] use `simple` for binary/multi-class classification, then `value` is a list of 0-1 labels
   type: simple
   value: [
      label_H_bb, #label_H_cc, label_H_qq,
      sample_isQCD*(label_QCD_others+label_QCD_b+label_QCD_c+label_QCD_bb+label_QCD_cc)
      # label_QCD_bb, label_QCD_cc, label_QCD_b, label_QCD_c, label_QCD_others,
      ]
   ### [option 2] otherwise use `custom` to define the label, then `value` is a map
   # type: custom
   # value: 
      # target_mass: np.where(fj_isQCD, fj_genjet_sdmass, fj_gen_mass) 

observers:
   - event_no
   - fj_pt
   - fj_eta
   - fj_phi
   - fj_sdmass
   - npfcands

# weights:
#    ### [option 1] use precomputed weights stored in the input files
#    # use_precomputed_weights: true
#    # weight_branches: [weight, class_weight]
#    ### [option 2] compute weights on-the-fly using reweighting histograms
#    use_precomputed_weights: false
#    reweight_method: flat
#    reweight_vars:
#       fj_pt: [170, 203, 242, 289, 346, 413, 493, 589, 704, 841, 1004, 1200]
#       fj_sdmass: [30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260]
#    reweight_classes: [fj_isQCD, label_H_bb] # label_H_cc, label_H_qq]
#    class_weights: [1, 1] #, 1, 1]
#    reweight_hists:

